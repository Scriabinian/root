@getter/setter
접근제어자 -> private :  인캡슐레이션;
객체의 필드를 객체의 내부 뿐만 아니라 객체 밖에서도 마음껏 생성자를 통해서 사용할 수 있게돼었당.
필드를 보호하는 검증된 필드를 대입할 수 있으며, 외부에서 사용할 필드값을 정제한 후 값을 제공받음.
1)setter 메서드
생성자의 입력된 값을 사용하기 전에 검증을 하고싶은.
필드 접근을 제한할 수 있다.
2)getter 메서드
private한 필드를 개체 외부에서 값을 불러오기 위해 구현하는 메서드당. 멧 ㅓ드를 통해서만 값을 전달받음.
@컨스트럭터 : 오버로딩;
객체를 생성할 때 호출되어 객체의 초기화를 담당함.
라이브러리용 클래스는 모든 생성자를 갖고있당 = 여러 객체를 마음껏 만든당.(클래스->객체1, 객체2...)

기본 생성자
모든 클래스에는 하나 이상의 생성자가 정의되어 있으며, 클래스를 생성하면서 선언하지 않았지만, 컴파일러가 기본생성자 제공.
인스턴스 초기화 작업이 요구되지 않는다면, 생성자를 정의하지 않아도 되고, 기본생성자 사용해도됨.=자율적이지만, 프로그래머가 세부적인 클래스를 설계할 경우 사용된당.
클래스-->객체 초기화-->메모리(객체):멤버변수/멤버메소드 초기화하기위해.
1. 생성자의 이름은 클라스의 이름과 같당.
2.리턴없음.
3.생성자도 오버로딩 가능.
4.생성자도 메서드이기 때문에, 없는 리턴값 생략가능.

@생성자 오버로딩 ㅎ ㅅㅎ.
1)오버로딩 
생성자를 다양한 매개변수 형태로 성형가능.
2)생성자 오버로딩 종류
-매개변수의 초기화가 부족할 경우 다양한 기본생성자 만들기 가능.
-매개변수의 갯구가 똑같더라도 데이터형이 다르면 다른생성자.
-매개변수가 같은 데이터형이라도 개수가 다르면 다른생성자.

3)this 사용방법 ㅎ ㅅㅎ
인스턴스가 자기 자신을 참조하는 변수.
클래스의 멤버변수를 참조.
this.필드 = 매개변수명;
//기본생성(int 매개변수명)
4)this 특징;;
5)생성자를 이용한 인스턴스 복사.
참조변수를 매개변수로 받아서 인스턴스 변수 값을 복사함.
Car car = new Car();
Car car2 = new Car(car);//참조변수로 객체를 받는당 ㅎ ㅅㅎ.
인스턴스를 생성할 때 고려사항.
1)클라스 - 어떤 클래스의 인스턴스를 생성하냐
2)생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것이냐?


@상속
부모의 클라스(설계도) 자식에게 물려줘서 자식은  부모와 나를 함께 구현할 수 있고, 자식은 상속을 통해서 하나의 부모만 의존한당.
상속클래스 : 부모클래스/상위클래스/기반클래스/
상속받는 클래스:자식/하위/파생클래스...
-구현방법 ㅎ ㅅㅎ
class A{}
class B extends A{//자식클래스(B클래스는 의존함.)}
1)super() 메서드(부모 기본 생성자)
부모 클래스의 생성자가 호출될 때 매개변수 값을 전달받아 부모 클래스의 필드들을 초기화 한다면 자식이 생성될때 부모생성자를 넣어줘야함.
-본생성자가 호출되면 부모기본생성자가 호출
-부모 객체를 먼저 생성하고, 자식 객체를 생성해야함 ㅎㅎ.